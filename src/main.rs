use std::{env, fmt::Debug, io::Cursor, net::UdpSocket};

use anyhow::Result;
use binrw::{BinRead, BinWrite};
use clap::{Parser, Subcommand};
use color::{AlphaColor, ColorSpaceTag, DynamicColor, Hsl, HueDirection};

#[derive(Debug, BinWrite)]
#[bw(little)]
enum AkariMessage {
  #[brw(magic = b"PNG")]
  Ping,
  #[brw(magic = b"INF")]
  Info,
  #[brw(magic = b"TGL")]
  Toggle,
  #[brw(magic = b"SET")]
  Set(Vec<(u8, u8, u8)>),
  #[brw(magic = b"BRI")]
  Brightness(u8),
  #[brw(magic = b"MOD")]
  Mode(u8),
}

impl AkariMessage {
  fn message(self) -> Vec<u8> {
    let mut buf = Cursor::new(vec![]);
    self.write(&mut buf).unwrap();
    buf.into_inner()
  }
}

#[derive(Debug, BinRead)]
#[br(little)]
enum AkariResponse {
  #[br(magic = b"PNG")]
  Pong,
  #[br(magic = b"INF")]
  Info {
    length: u8,
    brightness: u8,
    on: u8,
  },
}

impl AkariResponse {
  fn wait_for(socket: &UdpSocket) -> Result<AkariResponse> {
    let mut buf = [0u8; 256];
    let (len, _) = socket.recv_from(&mut buf)?;
    Ok(AkariResponse::read(&mut Cursor::new(&buf[..len]))?)
  }
}

#[derive(Debug, Parser)]
struct AkariCli {
  #[command(subcommand)]
  command: AkariCommand
}

#[derive(Debug, Subcommand)]
enum AkariCommand {
  Ping,
  Info {
    #[clap(short, action)]
    json: bool,
  },
  Toggle,
  #[command(name = "colors")]
  SetColors {
    colors: Vec<String>,
  },
  #[command(name = "brightness")]
  SetBrightness {
    brightness: u8
  },
  #[command(name = "mode")]
  SetMode {
    mode: u8,
  },
}

fn construct_gradient(colors: &[DynamicColor], length: usize) -> Vec<(u8, u8, u8)> {
  let mut gradient = vec![(0, 0, 0); length];

  let segments = (0..colors.len())
    .map(|i| colors[i].interpolate(colors[(i+1)%colors.len()], ColorSpaceTag::Srgb, HueDirection::Shorter))
    .collect::<Vec<_>>();

  let segment_len = length as f32 / colors.len() as f32;

  for i in 0..length {
    let segment = segments[(i as f32 / segment_len).floor() as usize];
    let progress = (i as f32 % segment_len) / segment_len;

    // colors generated by matugen
    // look very dull on my led strip
    // so saturation is set here to make them look nicer irl
    let mut col: AlphaColor<Hsl> = segment.eval(progress).to_alpha_color();
    col.components[1] = 80.;

    let col = col.to_rgba8();

    gradient[i] = (col.r, col.g, col.b);
  }

  gradient
}

fn main() -> Result<()> {
  let socket = UdpSocket::bind("0.0.0.0:0")?;
  let address = env!("MCU_ADDRESS");

  let length = {
    let command = AkariMessage::Info;
    socket.send_to(&command.message(), &address)?;
    match AkariResponse::wait_for(&socket) {
      Ok(AkariResponse::Info { length, .. }) => length,
      _ => panic!("No info received from server")
    }
  } as usize;

  let cli = AkariCli::parse();

  match cli.command {
    AkariCommand::Ping => {
      let message = AkariMessage::Ping;
      socket.send_to(&message.message(), &address)?;
      let pong = AkariResponse::wait_for(&socket)?;
      assert!(matches!(pong, AkariResponse::Pong));
      println!("Pong");
    }
    AkariCommand::Info { json } => {
      let message = AkariMessage::Info;
      socket.send_to(&message.message(), &address)?;
      let info = AkariResponse::wait_for(&socket)?;
      match info {
        AkariResponse::Info {
          length,
          brightness,
          on
        } => {
          let on = on > 0;
          if json {
            println!(r#"{{"leds":{},"brightness":{},"on":{}}}"#, length, brightness, on);
          } else {
            println!("{} LEDs | Brightness: {}/255 | {}", length, brightness, if on { "on" } else { "off" });
          }
        },
        _ => {}
      }
    },
    AkariCommand::Toggle => {
      let message = AkariMessage::Toggle;
      socket.send_to(&message.message(), &address)?;
    },
    AkariCommand::SetColors { colors } => {
      if colors.is_empty() {
        return Ok(());
      }

      let colors: Vec<_> = colors.iter().map(|c| color::parse_color(&format!("#{c}")).unwrap()).collect();
      let gradient = construct_gradient(&colors, length);
      #[cfg(debug_assertions)]
      {
        let gradient_string: String = gradient.iter().map(|c| format!("\x1b[48;2;{};{};{}m ", c.0, c.1, c.2)).collect();
        println!("{}\x1b[0m", gradient_string);
      }
      let message = AkariMessage::Set(gradient);
      socket.send_to(&message.message(), &address)?;
    },
    AkariCommand::SetBrightness { brightness } => {
      let message = AkariMessage::Brightness(brightness);
      socket.send_to(&message.message(), &address)?;
    }
    AkariCommand::SetMode { mode } => {
      let message = AkariMessage::Mode(mode);
      socket.send_to(&message.message(), &address)?;
    }
  }

  Ok(())
}